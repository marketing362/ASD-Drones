<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>ASD SAR – Mapa de probabilidad de desplazamiento (v3)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <style>
    :root {
      --bg: #020617;
      --panel: #020617;
      --panel-border: #1f2937;
      --accent: #38bdf8;
      --accent-soft: rgba(56,189,248,0.15);
      --text: #e5e7eb;
      --muted: #9ca3af;
      --danger: #f97373;
    }
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #111827, #020617 45%, #000 100%);
      color: var(--text);
    }
    .layout {
      display: grid;
      grid-template-columns: 360px minmax(0, 1fr);
      height: 100vh;
    }
    @media (max-width: 900px) {
      .layout {
        grid-template-columns: minmax(0, 1fr);
        grid-template-rows: auto minmax(0, 1fr);
      }
    }
    .panel {
      padding: 14px 16px;
      background: var(--panel);
      border-right: 1px solid var(--panel-border);
      box-shadow: 8px 0 30px rgba(0,0,0,0.6);
      z-index: 1000;
      overflow-y: auto;
    }
    @media (max-width:900px){
      .panel {
        border-right: none;
        border-bottom: 1px solid var(--panel-border);
        box-shadow: 0 8px 30px rgba(0,0,0,0.6);
      }
    }
    h1 {
      font-size: 1.05rem;
      margin: 0 0 4px;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .badge {
      font-size: 0.7rem;
      text-transform: uppercase;
      padding: 2px 7px;
      border-radius: 999px;
      border: 1px solid var(--accent);
      color: var(--accent);
      background: var(--accent-soft);
    }
    .subtitle {
      font-size: 0.8rem;
      color: var(--muted);
      margin-bottom: 8px;
    }
    .group-title {
      font-size: 0.8rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
      margin: 10px 0 4px;
    }
    label {
      display: flex;
      flex-direction: column;
      gap: 3px;
      font-size: 0.8rem;
      margin-bottom: 6px;
    }
    input, select {
      background: #020617;
      border-radius: 8px;
      border: 1px solid #1f2937;
      padding: 6px 8px;
      color: var(--text);
      font-size: 0.8rem;
      outline: none;
    }
    input:focus, select:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent-soft);
    }
    .small {
      font-size: 0.72rem;
      color: var(--muted);
    }
    .row-2 {
      display: grid;
      grid-template-columns: repeat(2, minmax(0,1fr));
      gap: 6px;
    }
    .btn-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 8px;
      margin-bottom: 6px;
    }
    button {
      border-radius: 999px;
      border: none;
      padding: 6px 10px;
      font-size: 0.75rem;
      font-weight: 600;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 5px;
    }
    button.primary {
      background: var(--accent);
      color: #020617;
    }
    button.secondary {
      background: #020617;
      color: var(--muted);
      border: 1px solid #1f2937;
    }
    button.danger {
      background: #450a0a;
      color: #fecaca;
      border: 1px solid #7f1d1d;
    }
    button[disabled] {
      opacity: 0.5;
      cursor: default;
    }
    #map {
      width: 100%;
      height: 100%;
    }
    .status {
      border-radius: 8px;
      border: 1px solid #1f2937;
      padding: 6px 8px;
      font-size: 0.75rem;
      color: var(--muted);
      margin-top: 4px;
    }
    .status strong { color: var(--text); }
    .warning {
      font-size: 0.7rem;
      color: var(--danger);
      margin-top: 6px;
    }
  </style>
</head>
<body>
<div class="layout">
  <aside class="panel">
    <h1>
      ASD SAR
      <span class="badge">Mapa probabilidad v3</span>
    </h1>
    <div class="subtitle">
      LKP + objetivo + perfil víctima + tiempo → zonas de probabilidad de desplazamiento. Esta versión permite exportar el perímetro en <strong>KML</strong> para misiones autónomas de dron.
    </div>

    <div class="group-title">Puntos en el mapa</div>
    <div class="btn-row">
      <button type="button" class="secondary" id="btnSetLkp">Marcar LKP</button>
      <button type="button" class="secondary" id="btnSetTarget">Marcar objetivo</button>
      <button type="button" class="danger" id="btnClearPoints">Borrar puntos</button>
    </div>
    <div class="status" id="pointsStatus">
      LKP: <strong>no definido</strong><br>
      Objetivo: <strong>no definido</strong>
    </div>

    <div class="group-title">Cronología</div>
    <div class="row-2">
      <label>
        Fecha desaparición
        <input type="date" id="lostDate" />
      </label>
      <label>
        Hora desaparición
        <input type="time" id="lostTime" />
      </label>
    </div>
    <label>
      Tiempo máximo caminando (horas)
      <input type="number" id="hours" min="0" step="0.25" placeholder="Ej: 3" />
      <span class="small">Tiempo razonable máximo desde la desaparición hasta ahora (parámetro operativo).</span>
    </label>

    <div class="group-title">Datos de la víctima</div>
    <label>
      Edad (años)
      <input type="number" id="age" min="0" step="1" placeholder="Ej: 70" />
    </label>
    <label>
      Condición / patología
      <select id="condition">
        <option value="adulto">Adulto sano / estándar</option>
        <option value="mayor">Mayor frágil</option>
        <option value="nino">Niño</option>
        <option value="alzheimer">Alzheimer / demencia</option>
        <option value="depresion">Depresión / conducta suicida</option>
        <option value="desorientado">Desorientado sin patología conocida</option>
      </select>
    </label>
    <label>
      Tipo de terreno (global)
      <select id="terrain">
        <option value="llano">Llano / pistas fáciles</option>
        <option value="colinas">Colinas / media montaña</option>
        <option value="alta">Alta montaña / terreno duro</option>
      </select>
    </label>

    <div class="btn-row">
      <button type="button" class="primary" id="btnCalc">Calcular zona</button>
      <button type="button" class="secondary" id="btnClearZones">Borrar zonas</button>
    </div>

    <div class="btn-row">
      <button type="button" class="secondary" id="btnExportKml" disabled>Exportar perímetro KML</button>
    </div>

    <div class="status" id="calcStatus">
      Velocidad estimada: <strong>–</strong><br>
      Distancia máxima (ideal): <strong>–</strong><br>
      Nota: <span class="small">v3 simplificada (sin DEM). El perímetro KML exportado incluye: círculo de alcance máximo alrededor de LKP + corredor hacia el objetivo.</span>
    </div>

    <div class="status" id="legendBox">
      <strong>Leyenda operativa (resumen parámetros)</strong><br>
      Fecha/hora desaparición: <span class="small">–</span><br>
      LKP: <span class="small">–</span><br>
      Objetivo: <span class="small">–</span><br>
      Perfil: <span class="small">–</span><br>
      Terreno: <span class="small">–</span><br>
      Tiempo máx. caminando: <span class="small">–</span>
    </div>

    <div class="warning">
      ⚠ Herramienta de apoyo táctico. No sustituye criterio SAR, protocolos oficiales ni productos GIS con orografía real. Revisa siempre el perímetro exportado antes de volcarlo a una misión autónoma.
    </div>
  </aside>

  <main id="map"></main>
</div>

<!-- Leaflet JS -->
<script
  src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
  integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
  crossorigin=""
></script>
<script>
  // Mapa base centrado en España
  const map = L.map('map').setView([40.2, -3.7], 6);

  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 18,
    attribution: '&copy; OpenStreetMap'
  }).addTo(map);

  let mode = null; // "lkp" | "target" | null
  let lkpMarker = null;
  let targetMarker = null;
  let zones = [];
  let exportData = null; // datos para generar KML

  const btnSetLkp = document.getElementById('btnSetLkp');
  const btnSetTarget = document.getElementById('btnSetTarget');
  const btnClearPoints = document.getElementById('btnClearPoints');
  const btnCalc = document.getElementById('btnCalc');
  const btnClearZones = document.getElementById('btnClearZones');
  const btnExportKml = document.getElementById('btnExportKml');
  const pointsStatus = document.getElementById('pointsStatus');
  const calcStatus = document.getElementById('calcStatus');
  const legendBox = document.getElementById('legendBox');

  function updatePointsStatus() {
    const lkpText = lkpMarker
      ? lkpMarker.getLatLng().lat.toFixed(5) + ', ' + lkpMarker.getLatLng().lng.toFixed(5)
      : 'no definido';
    const targetText = targetMarker
      ? targetMarker.getLatLng().lat.toFixed(5) + ', ' + targetMarker.getLatLng().lng.toFixed(5)
      : 'no definido';
    pointsStatus.innerHTML = 'LKP: <strong>' + lkpText +
      '</strong><br>Objetivo: <strong>' + targetText + '</strong>';
  }

  btnSetLkp.addEventListener('click', () => {
    mode = 'lkp';
    btnSetLkp.classList.add('primary');
    btnSetTarget.classList.remove('primary');
  });

  btnSetTarget.addEventListener('click', () => {
    mode = 'target';
    btnSetTarget.classList.add('primary');
    btnSetLkp.classList.remove('primary');
  });

  btnClearPoints.addEventListener('click', () => {
    if (lkpMarker) { map.removeLayer(lkpMarker); lkpMarker = null; }
    if (targetMarker) { map.removeLayer(targetMarker); targetMarker = null; }
    mode = null;
    btnSetLkp.classList.remove('primary');
    btnSetTarget.classList.remove('primary');
    updatePointsStatus();
    updateLegend();
  });

  btnClearZones.addEventListener('click', () => {
    zones.forEach(z => map.removeLayer(z));
    zones = [];
    exportData = null;
    btnExportKml.disabled = true;
    calcStatus.innerHTML = 'Velocidad estimada: <strong>–</strong><br>Distancia máxima (ideal): <strong>–</strong><br>Nota: <span class="small">v3 simplificada (sin DEM). El perímetro KML exportado incluye: círculo de alcance máximo alrededor de LKP + corredor hacia el objetivo.</span>';
  });

  map.on('click', (e) => {
    if (!mode) return;
    if (mode === 'lkp') {
      if (lkpMarker) map.removeLayer(lkpMarker);
      lkpMarker = L.marker(e.latlng, { draggable: true }).addTo(map).bindTooltip('LKP', {permanent:true, direction:'top'});
      lkpMarker.on('dragend', () => { updatePointsStatus(); updateLegend(); });
    } else if (mode === 'target') {
      if (targetMarker) map.removeLayer(targetMarker);
      targetMarker = L.marker(e.latlng, { draggable: true }).addTo(map).bindTooltip('Objetivo', {permanent:true, direction:'top'});
      targetMarker.on('dragend', () => { updatePointsStatus(); updateLegend(); });
    }
    updatePointsStatus();
    updateLegend();
  });

  function haversineDistance(latlng1, latlng2) {
    const R = 6371e3; // m
    const toRad = x => x * Math.PI / 180;
    const dLat = toRad(latlng2.lat - latlng1.lat);
    const dLon = toRad(latlng2.lng - latlng1.lng);
    const lat1 = toRad(latlng1.lat);
    const lat2 = toRad(latlng2.lat);

    const a = Math.sin(dLat/2)**2 +
              Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2;
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c; // m
  }

  function estimateSpeed(condition, terrain, age) {
    // Velocidades base (km/h) muy simplificadas
    let base = 3.0; // adulto estándar
    if (condition === 'mayor') base = 2.2;
    if (condition === 'nino') base = 2.0;
    if (condition === 'alzheimer') base = 1.8;
    if (condition === 'depresion') base = 2.5;
    if (condition === 'desorientado') base = 2.4;

    // Ajuste por edad (opcional)
    if (!isNaN(age)) {
      if (age >= 70) base *= 0.8;
      else if (age <= 12) base *= 0.9;
    }

    // Ajuste por terreno global
    if (terrain === 'colinas') base *= 0.8;
    if (terrain === 'alta') base *= 0.6;

    return base; // km/h
  }

  function updateLegend() {
    const lostDate = document.getElementById('lostDate').value || '–';
    const lostTime = document.getElementById('lostTime').value || '–';
    const hours = document.getElementById('hours').value || '–';
    const ageVal = document.getElementById('age').value || '–';
    const conditionSel = document.getElementById('condition');
    const conditionText = conditionSel.options[conditionSel.selectedIndex].text;
    const terrainSel = document.getElementById('terrain');
    const terrainText = terrainSel.options[terrainSel.selectedIndex].text;

    const lkpText = lkpMarker
      ? lkpMarker.getLatLng().lat.toFixed(5) + ', ' + lkpMarker.getLatLng().lng.toFixed(5)
      : '–';
    const targetText = targetMarker
      ? targetMarker.getLatLng().lat.toFixed(5) + ', ' + targetMarker.getLatLng().lng.toFixed(5)
      : '–';

    legendBox.innerHTML =
      '<strong>Leyenda operativa (resumen parámetros)</strong><br>' +
      'Fecha/hora desaparición: <span class="small">' + lostDate + ' ' + lostTime + '</span><br>' +
      'LKP: <span class="small">' + lkpText + '</span><br>' +
      'Objetivo: <span class="small">' + targetText + '</span><br>' +
      'Perfil: <span class="small">Edad ' + ageVal + ' · ' + conditionText + '</span><br>' +
      'Terreno: <span class="small">' + terrainText + '</span><br>' +
      'Tiempo máx. caminando: <span class="small">' + hours + ' h</span>';
  }

  btnCalc.addEventListener('click', () => {
    if (!lkpMarker) {
      alert('Marca al menos la última posición conocida (LKP).');
      return;
    }

    const age = parseInt(document.getElementById('age').value, 10);
    const condition = document.getElementById('condition').value;
    const terrain = document.getElementById('terrain').value;
    const hours = parseFloat(document.getElementById('hours').value);

    if (isNaN(hours) || hours <= 0) {
      alert('Indica un tiempo máximo caminando válido (horas).');
      return;
    }

    const speed = estimateSpeed(condition, terrain, age); // km/h
    const maxDistKm = speed * hours; // km

    // Limpiamos zonas anteriores
    zones.forEach(z => map.removeLayer(z));
    zones = [];
    exportData = null;
    btnExportKml.disabled = true;

    const lkp = lkpMarker.getLatLng();

    // Círculos de probabilidad (simplificados, alrededor LKP)
    const r1 = maxDistKm * 1000 * 0.4; // 40% del alcance máximo
    const r2 = maxDistKm * 1000 * 0.7; // 70%
    const r3 = maxDistKm * 1000;       // 100% -> perímetro "macro" de misión

    const circle1 = L.circle(lkp, {
      radius: r1,
      color: '#22c55e',
      fillColor: '#22c55e',
      fillOpacity: 0.14,
      weight: 1
    }).addTo(map);
    const circle2 = L.circle(lkp, {
      radius: r2,
      color: '#eab308',
      fillColor: '#eab308',
      fillOpacity: 0.09,
      weight: 1,
      dashArray: '4,4'
    }).addTo(map);
    const circle3 = L.circle(lkp, {
      radius: r3,
      color: '#f97316',
      fillColor: '#f97316',
      fillOpacity: 0.05,
      weight: 1,
      dashArray: '2,6'
    }).addTo(map);

    zones.push(circle1, circle2, circle3);

    // Datos de corredor hacia objetivo
    let corridorCenters = [];
    let corridorRadius = maxDistKm * 1000 * 0.22; // ancho del corredor

    if (targetMarker) {
      const target = targetMarker.getLatLng();
      const distLkpTargetKm = haversineDistance(lkp, target) / 1000; // km

      // Polyline LKP-Objetivo (referencia visual)
      const line = L.polyline([lkp, target], {
        color: '#38bdf8',
        weight: 2,
        opacity: 0.8
      }).addTo(map);
      zones.push(line);

      // Hasta dónde puede avanzar hacia el objetivo (si no llega, se queda a medio camino)
      const factorReach = Math.min(1, maxDistKm / Math.max(distLkpTargetKm, 0.001));

      // Creamos un corredor con varias "manchas" a lo largo del vector LKP→Objetivo
      const steps = 8;
      for (let i = 0; i <= steps; i++) {
        const t = factorReach * (i / steps);
        const lat = lkp.lat + (target.lat - lkp.lat) * t;
        const lng = lkp.lng + (target.lng - lkp.lng) * t;
        const p = L.latLng(lat, lng);
        corridorCenters.push(p);
        const c = L.circle(p, {
          radius: corridorRadius,
          color: '#fb7185',
          fillColor: '#fb7185',
          fillOpacity: 0.18,
          weight: 1
        }).addTo(map);
        zones.push(c);
      }

      map.fitBounds(L.latLngBounds([lkp, target]).pad(0.5));
    } else {
      map.fitBounds(circle3.getBounds().pad(0.25));
    }

    calcStatus.innerHTML =
      'Velocidad estimada: <strong>' + speed.toFixed(1) + ' km/h</strong><br>' +
      'Distancia máxima (ideal): <strong>' + maxDistKm.toFixed(1) + ' km</strong><br>' +
      '<span class="small">Nota: cálculo simplificado (sin DEM). El perímetro exportado usa el círculo de alcance máximo y, si hay objetivo, un corredor alrededor del eje LKP→Objetivo.</span>';

    // Guardamos datos para exportación KML
    exportData = {
      lkp: lkp,
      target: targetMarker ? targetMarker.getLatLng() : null,
      maxRadius: r3,
      corridorCenters: corridorCenters,
      corridorRadius: corridorRadius
    };
    btnExportKml.disabled = false;

    updateLegend();
  });

  // Actualizar leyenda cuando cambien datos
  document.getElementById('lostDate').addEventListener('change', updateLegend);
  document.getElementById('lostTime').addEventListener('change', updateLegend);
  document.getElementById('hours').addEventListener('input', updateLegend);
  document.getElementById('age').addEventListener('input', updateLegend);
  document.getElementById('condition').addEventListener('change', updateLegend);
  document.getElementById('terrain').addEventListener('change', updateLegend);

  // ---- Exportación KML ----

  function circleToPolygonCoords(center, radiusMeters, segments = 72) {
    const coords = [];
    const R = 6371e3; // Earth radius in meters
    const lat1 = center.lat * Math.PI / 180;
    const lon1 = center.lng * Math.PI / 180;
    const d = radiusMeters / R; // angular distance

    for (let i = 0; i <= segments; i++) {
      const brng = (i / segments) * 2 * Math.PI;
      const lat2 = Math.asin(Math.sin(lat1) * Math.cos(d) +
                             Math.cos(lat1) * Math.sin(d) * Math.cos(brng));
      const lon2 = lon1 + Math.atan2(Math.sin(brng) * Math.sin(d) * Math.cos(lat1),
                                     Math.cos(d) - Math.sin(lat1) * Math.sin(lat2));
      const latDeg = lat2 * 180 / Math.PI;
      const lonDeg = lon2 * 180 / Math.PI;
      coords.push([lonDeg, latDeg]); // KML order: lon,lat
    }
    return coords;
  }

  function buildKml(exportData) {
    if (!exportData || !exportData.lkp) return null;

    const lkp = exportData.lkp;
    const target = exportData.target;
    const maxRadius = exportData.maxRadius;
    const corridorCenters = exportData.corridorCenters || [];
    const corridorRadius = exportData.corridorRadius || 0;

    // 1) Perímetro principal: círculo máximo alrededor de LKP
    const circleCoords = circleToPolygonCoords(lkp, maxRadius, 72);

    // 2) Si hay corredor, generamos polígonos para cada centro (podrás fusionarlos en GIS si quieres)
    let corridorPolygons = [];
    if (target && corridorCenters.length > 0 && corridorRadius > 0) {
      corridorCenters.forEach(c => {
        corridorPolygons.push(circleToPolygonCoords(c, corridorRadius, 36));
      });
    }

    // 3) Estructura KML
    let kml = '';
    kml += '<?xml version="1.0" encoding="UTF-8"?>\n';
    kml += '<kml xmlns="http://www.opengis.net/kml/2.2">\n';
    kml += '  <Document>\n';
    kml += '    <name>ASD_SAR_Perimetro_Probabilidad</name>\n';

    // Estilos
    kml += '    <Style id="perimetroMaximo">\n';
    kml += '      <LineStyle><color>ff1670f9</color><width>2</width></LineStyle>\n';
    kml += '      <PolyStyle><color>401670f9</color></PolyStyle>\n';
    kml += '    </Style>\n';
    kml += '    <Style id="corredor">\n';
    kml += '      <LineStyle><color>ff7f00ff</color><width>1.5</width></LineStyle>\n';
    kml += '      <PolyStyle><color>407f00ff</color></PolyStyle>\n';
    kml += '    </Style>\n';
    kml += '    <Style id="lkpStyle">\n';
    kml += '      <IconStyle><color>ff00ff00</color><scale>1.1</scale></IconStyle>\n';
    kml += '    </Style>\n';
    kml += '    <Style id="targetStyle">\n';
    kml += '      <IconStyle><color>ff0000ff</color><scale>1.1</scale></IconStyle>\n';
    kml += '    </Style>\n';

    // Marcadores LKP y Objetivo
    kml += '    <Placemark>\n';
    kml += '      <name>LKP</name>\n';
    kml += '      <Point><coordinates>' + lkp.lng + ',' + lkp.lat + ',0</coordinates></Point>\n';
    kml += '    </Placemark>\n';

    if (target) {
      kml += '    <Placemark>\n';
      kml += '      <name>Objetivo</name>\n';
      kml += '      <Point><coordinates>' + target.lng + ',' + target.lat + ',0</coordinates></Point>\n';
      kml += '    </Placemark>\n';

      // Linea LKP-Objetivo
      kml += '    <Placemark>\n';
      kml += '      <name>Eje LKP-Objetivo</name>\n';
      kml += '      <LineString>\n';
      kml += '        <coordinates>' + lkp.lng + ',' + lkp.lat + ',0 ' + target.lng + ',' + target.lat + ',0</coordinates>\n';
      kml += '      </LineString>\n';
      kml += '    </Placemark>\n';
    }

    // Polígono principal
    kml += '    <Placemark>\n';
    kml += '      <name>Perímetro máximo (radio)</name>\n';
    kml += '      <styleUrl>#perimetroMaximo</styleUrl>\n';
    kml += '      <Polygon>\n';
    kml += '        <outerBoundaryIs>\n';
    kml += '          <LinearRing>\n';
    kml += '            <coordinates>\n';
    circleCoords.forEach(c => {
      kml += '              ' + c[0] + ',' + c[1] + ',0\n';
    });
    kml += '            </coordinates>\n';
    kml += '          </LinearRing>\n';
    kml += '        </outerBoundaryIs>\n';
    kml += '      </Polygon>\n';
    kml += '    </Placemark>\n';

    // Corredor como múltiples polígonos
    corridorPolygons.forEach((poly, idx) => {
      kml += '    <Placemark>\n';
      kml += '      <name>Corredor segmento ' + (idx+1) + '</name>\n';
      kml += '      <styleUrl>#corredor</styleUrl>\n';
      kml += '      <Polygon>\n';
      kml += '        <outerBoundaryIs>\n';
      kml += '          <LinearRing>\n';
      kml += '            <coordinates>\n';
      poly.forEach(c => {
        kml += '              ' + c[0] + ',' + c[1] + ',0\n';
      });
      kml += '            </coordinates>\n';
      kml += '          </LinearRing>\n';
      kml += '        </outerBoundaryIs>\n';
      kml += '      </Polygon>\n';
      kml += '    </Placemark>\n';
    });

    kml += '  </Document>\n';
    kml += '</kml>\n';

    return kml;
  }

  btnExportKml.addEventListener('click', () => {
    if (!exportData) {
      alert('Calcula primero una zona de probabilidad.');
      return;
    }
    const kml = buildKml(exportData);
    if (!kml) {
      alert('No se ha podido generar el KML.');
      return;
    }

    const blob = new Blob([kml], { type: 'application/vnd.google-earth.kml+xml' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    const now = new Date();
    const ts = now.toISOString().replace(/[:.]/g, '-');
    a.href = url;
    a.download = 'ASD_SAR_Perimetro_' + ts + '.kml';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  });
</script>
</body>
</html>
